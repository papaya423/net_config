# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'ac_config.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
# -*- coding: utf-8 -*-
import os
import struct
import time

# Form implementation generated from reading ui file 'mainwindow.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


# SPDX-License-Identifier: GPL-2.0-or-later
from PyQt5 import QtCore
from PyQt5.QtCore import pyqtSignal, QObject, QSize,Qt,QCoreApplication
from PyQt5.QtGui import QColor, QFont, QPalette
from PyQt5.QtWidgets import QWidget, QPushButton, QHBoxLayout, QVBoxLayout, QSizePolicy, QGridLayout, QLabel, QSlider, \
    QComboBox, QColorDialog, QCheckBox, QLineEdit, QButtonGroup, QRadioButton, QFileDialog, QMessageBox, QTextEdit, \
    QTreeWidget, QTreeWidgetItem
from PyQt5.QtGui import QColor,QImage,QPixmap
from basic_editor import BasicEditor
from Send_alarm import SendAlarm
from PIL import Image
import cv2
import re
tr = QCoreApplication.translate


class BasicHandler(QObject):
    update = pyqtSignal()

    def __init__(self, container):
        super().__init__()
        self.device = self.keyboard = None
        self.widgets = []

    def set_device(self, device):
        self.device = device
        if self.valid():
            # self.keyboard = self.device.keyboard
            self.show()
        else:
            self.hide()

    def show(self):
        for w in self.widgets:
            w.show()

    def hide(self):
        for w in self.widgets:
            w.hide()

    def block_signals(self):
        for w in self.widgets:
            w.blockSignals(True)

    def unblock_signals(self):
        for w in self.widgets:
            w.blockSignals(False)

    # def update_from_keyboard(self):
    #     raise NotImplementedError
    #
    # def valid(self):
    #     raise NotImplementedError

class NetConfigSetHandler(BasicHandler):

    def __init__(self, container):
        super().__init__(container)

    def valid(self):
        return 1
        # return isinstance(self.device, VialKeyboard) #and self.device.keyboard.lighting_qmk_rgblight

    def send_cmd(self,strmsg):
        byte_array = strmsg.encode()
        print(type(byte_array),len(byte_array))  # <class 'bytes'>
        print(byte_array)  #
        #hex_data = byte_array.hex()
        return self.device.keyboard.set_custom_setting(byte_array)


    def send_cmd_str(self,strmsg):
        byte_array = strmsg.encode()
        print(type(byte_array),len(byte_array))  # <class 'bytes'>
        print(byte_array)  #
        try:
            return self.device.keyboard.set_custom_setting(byte_array)
        except:
            return None
    def send_cmd_hex(self,byte_array):
        #bytes_array是bytes,入参要转换为bytes传入进来
        ret =self.device.keyboard.set_custom_setting(byte_array)
        return ret

    def recv_cmd_hex(self):
        ret = self.device.keyboard.recv_custom_setting()
        return ret

class ac_config(BasicEditor):
    def __init__(self):
        super().__init__()
        self.data = dict()
        self.mode = 1

        w = QWidget()
        w.setSizePolicy(QSizePolicy.Maximum, QSizePolicy.Maximum)
        self.container = QVBoxLayout()

        w.setLayout(self.container)
        self.addWidget(w)
        self.setupUi(w,self.container)

        self.handlers = [NetConfigSetHandler(self.container)]


    #添加代码
    def setupUi(self,Form,contain):
        # self.label = QLabel("按钮")
        self.testButton = QPushButton("查看dhcp配置")
        self.arpButton = QPushButton("查看arp")
        self.testButton.clicked.connect(self.on_btn_test_clicked)
        self.arpButton.clicked.connect(self.on_btn_arp_clicked)

        self.lineEdit = QTextEdit()
        self.lineEdit.setFixedWidth(1300)

        self.testButton.setFixedSize(170, 60)  # 缩小查看配置按钮
        self.arpButton.setFixedSize(130, 60)  # 缩小查看ARP按钮

        # print(retstr)
        self.horizontalLayout = QHBoxLayout()
        self.horizontalLayout.addWidget(self.lineEdit)
        self.horizontalLayout.setStretch(1, 1)
        self.horizontalLayout.setStretch(1, 2)

        # 创建vlan输入框和按钮
        self.layout1 = QHBoxLayout()

        self.btn_yewu= QPushButton("dhcp实现ap通信")

        # 创建业务vlan和管理vlan的输入框
        self.yewu_label = QLabel("业务vlan地址")  # 创建QLabel
        self.yewu_inputIp = QLineEdit()
        self.btn_yewu.setToolTip(
         """这是业务功能的配置:
            sy
            sysname AC
            vlan batch 10
            dhcp enable 
            interface Vlanif10
            ip address 192.168.11.3 255.255.255.0
            dhcp select interface
            quit
            interface GigabitEthernet0/0/1 
            port link-type trunk
            port trunk pvid vlan 10
            undo port trunk allow-pass vlan 1
            port trunk allow-pass vlan 10
            quit""")
        self.btn_yewu.clicked.connect(self.on_btn_yewu_clicked)

        self.yewu_inputIp.setFixedSize(300,45)
        # 布局
        yewu_layout = QVBoxLayout()
        yewu_layout.addWidget(self.yewu_label)
        yewu_layout.addWidget(self.yewu_inputIp)
        yewu_layout.addWidget(self.btn_yewu)

        self.layout1.addLayout(yewu_layout)
        yewu_layout.setAlignment(QtCore.Qt.AlignLeft)

        # 将布局设置为窗口的主布局
        contain.addLayout(self.layout1)
        contain.addLayout(self.horizontalLayout)

        button_layout = QHBoxLayout()
        button_layout.addWidget(self.testButton)
        button_layout.addWidget(self.arpButton)
        # 将按钮布局设置为左对齐
        button_layout.setAlignment(Qt.AlignLeft)  # 左对齐
        contain.addLayout(button_layout)

    def on_btn_yewu_clicked(self):
        #print("dhcp")
        network_str = self.yewu_inputIp.text()
        print(network_str)
        self.device.execute_some_command("system-view")
        self.device.execute_some_command("sysname AC")  # 开启DHCP功能
        self.device.execute_some_command("undo info-center enable")  # 关闭消息提醒功能
        self.device.execute_some_command("dhcp enable")  # 开启DHCP功能
        result = self.device.execute_some_command("display ip int bri")
        if "Vlanif10" in result:
            print("vlan10已存在,正在删除...")
            self.device.execute_some_command("undo interface Vlanif 10")
        else:
            print("创建新的vlan10地址")
        self.device.execute_some_command("vlan batch 10 20")  # 进入VLANIF 10接口
        self.device.execute_some_command("interface Vlanif10")
        self.device.execute_some_command(f"ip add {network_str} 255.255.255.0")  # 定义网络地址和子网掩码
        self.device.execute_some_command("dhcp select interface")
        self.device.execute_some_command("quit")
        self.device.execute_some_command("interface GigabitEthernet0/0/1")
        self.device.execute_some_command("port link-type trunk")
        self.device.execute_some_command("port trunk pvid vlan 10")
        self.device.execute_some_command("undo port trunk allow-pass vlan 1")
        self.device.execute_some_command("port trunk allow-pass vlan 10")
        self.device.execute_some_command("quit")
        self.device.execute_some_command("display ip pool")  # 查看地址池配置
        self.device.execute_some_command("quit")  # 退出系统视图模式




    def on_radiobtn_Mode_clicked(self,button):
        id = self.radioModeGrp.id(button)
        self.mode=id;
        print(f"id={id}")


    def add_dict_to_tree(self, tree, data):
        for key, value in data.items():
            item = QTreeWidgetItem([key, str(value)])
            if isinstance(value, dict):
                self.add_dict_to_tree(tree, value)
            else:
                item.setFlags(item.flags() ^ 2)  # 去掉可编辑的标志
            tree.addTopLevelItem(item)

    def parse_data(self,config_str):
        config_dict = {}
        current_key = None
        current_sub_dict = None

        lines = config_str.split('\n')
        for line in lines:
            line = line.strip()

            # Skip comments and empty lines
            if not line or line.startswith('#'):
                continue

                # Handle nested structures like interfaces
            if line.endswith('{'):
                current_key = line[:-1].strip()
                current_sub_dict = {}
                config_dict[current_key] = current_sub_dict
            elif line.startswith('}'):
                current_key = None
                current_sub_dict = None
            else:
                # Split the line into key and value
                if ' ' in line:
                    key, value = line.split(' ', 1)
                    key = key.strip()
                    value = value.strip()
                else:
                    key = line.strip()
                    value = None

                if key in config_dict.keys():
                    current_sub_dict={}
                    valuetemp= config_dict[key]
                    if isinstance(valuetemp, list):
                        values = valuetemp+[value]
                    else:
                        values = [valuetemp,value]
                    config_dict[key] = values
                    # Handle nested keys
                # if current_sub_dict:
                #     current_sub_dict[key] = value
                #     # config_dict[key] = values
                else:
                    config_dict[key] = value

                    # Post-process to handle interfaces with configurations
        interface_pattern = re.compile(r'^interface\s+(\S+)')
        ip_address_pattern = re.compile(r'^ip\s+address\s+(\S+)\s+(\S+)')
        for key, value in list(config_dict.items()):
            if isinstance(value, dict):
                # Extract interface details
                match = interface_pattern.match(key)
                if match:
                    interface_name = match.group(1)
                    # Look for IP address configuration in the sub-dict
                    for sub_key, sub_value in value.items():
                        if isinstance(sub_value, dict):
                            ip_match = ip_address_pattern.match(' '.join(sub_value.keys()))
                            if ip_match:
                                ip_address = ip_match.group(1)
                                subnet_mask = ip_match.group(2)
                                # Update the dictionary structure
                                config_dict[interface_name] = {
                                    'type': 'interface',
                                    'ip_address': ip_address,
                                    'subnet_mask': subnet_mask,
                                    # Keep other configurations if any
                                    'config': {k: v for k, v in sub_value.items() if k not in ['ip address']}
                                }
                                # Remove the old interface entry
                                del config_dict[key]
                                break
        return self.flatten_dict(config_dict)
                                # Flatten the dictionary (remove empty nested dicts)

    def flatten_dict(self,d, parent_key='', sep='.'):
        items = []
        for k, v in d.items():
            new_key = f"{parent_key}{sep}{k}" if parent_key else k
            if isinstance(v, dict):
                items.extend(self.flatten_dict(v, new_key, sep=sep).items())
            else:
                items.append((new_key, v))
        return dict(items)

    #修改代码
    def on_btn_test_clicked(self):
        # QMessageBox.information(None, "测试", "单击了按钮")
        #在该函数下添加你想要做的操作代码
        retstr= self.device.execute_some_command("disp ip pool")
        self.device.execute_some_command(" ")
        self.lineEdit.setText(retstr)
        result =self.parse_data(retstr)
        print(result)

    def on_btn_arp_clicked(self):
        # 执行查看ARP表的命令
        retstr = self.device.execute_some_command("dis arp")
        self.device.execute_some_command(" ")
        self.lineEdit.setText(retstr)
        print(retstr)




 # layout 移除所有控件
    def remove_all_controls(self,layout):
        while layout.count():
            child = layout.takeAt(0)
            if child is not None:
                if child.widget() is not None:
                    child.widget().deleteLater()
                elif child.layout() is not None:
                    self.clear_layout(child.layout())

    def clear_layout(self,layout):
        while layout is not None and layout.count():
            item = layout.takeAt(0)
            widget = item.widget()
            if widget is not None:
                widget.deleteLater()
            else:
                self.clear_layout(item.layout())


    def valid(self):
        # return isinstance(self.device, VialKeyboard)
        return 1




    def rebuild(self, device):
        super().rebuild(device)

        for h in self.handlers:
            h.set_device(device)

        if not self.valid():
            return